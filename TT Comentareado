import tkinter as tk
from tkinter import filedialog, ttk
import pandas as pd
from sklearn.tree import DecisionTreeRegressor
from sklearn.preprocessing import StandardScaler, OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.impute import SimpleImputer
from sklearn.model_selection import GridSearchCV
from sklearn.metrics import mean_squared_error
import numpy as np

# Clase principal de la aplicación de limpieza de datos
class DataCleanerApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Data Cleaner")  # Título de la ventana principal
        self.root.geometry("600x600")  # Dimensiones de la ventana
        self.root.configure(bg='black')  # Color de fondo de la ventana
        self.data = None  # Inicialización de la variable que contendrá los datos

        # Interfaz gráfica
        self.label = tk.Label(root, text="Seleccionar archivo", width=40, height=10, bg="blue", fg="white", font=("century gothic", 14))
        self.label.pack(padx=20, pady=20)
        self.label.bind("<Button-1>", self.load_file)  # Evento para cargar archivo al hacer clic en la etiqueta

        self.clean_button = tk.Button(root, text="Limpiar Datos", command=self.clean_data, bg="navy", fg="white", font=("century gothic", 14))
        self.clean_button.pack(padx=20, pady=20)
        self.clean_button.config(state=tk.DISABLED)  # Botón desactivado hasta que se cargue un archivo
        
        self.save_button = tk.Button(root, text="Guardar Datos", command=self.save_data, bg="green", fg="white", font=("century gothic", 14))
        self.save_button.pack(padx=20, pady=20)
        self.save_button.config(state=tk.DISABLED)  # Botón desactivado hasta que los datos sean limpiados

        self.progress = ttk.Progressbar(root, orient='horizontal', length=400, mode='indeterminate')
        self.progress.pack(pady=10)  # Barra de progreso para mostrar el estado de la limpieza de datos

    # Método para cargar el archivo CSV
    def load_file(self, event):
        try:
            file_path = filedialog.askopenfilename(filetypes=[("CSV files", "*.csv")])  # Diálogo para seleccionar archivo
            if file_path:
                self.data = pd.read_csv(file_path)  # Leer el archivo CSV con pandas
                self.label.config(text="Archivo cargado: " + file_path.split("/")[-1])  # Mostrar el nombre del archivo cargado
                self.clean_button.config(state=tk.NORMAL)  # Habilitar el botón de limpiar datos
        except Exception as e:
            self.label.config(text=f"Error al cargar el archivo: {str(e)}")
            self.clean_button.config(state=tk.DISABLED)  # Desactivar el botón de limpiar datos en caso de error

    # Método para preprocesar los datos
    def preprocess_data(self, X):
        # Detectar y preprocesar características numéricas y categóricas
        numeric_features = X.select_dtypes(include=['float64', 'int64']).columns
        categorical_features = X.select_dtypes(include=['object', 'category']).columns

        # Transformaciones para características numéricas
        numeric_transformer = Pipeline(steps=[
            ('imputer', SimpleImputer(strategy='mean')),
            ('scaler', StandardScaler())
        ])

        # Transformaciones para características categóricas
        categorical_transformer = Pipeline(steps=[
            ('imputer', SimpleImputer(strategy='constant', fill_value='missing')),
            ('onehot', OneHotEncoder(handle_unknown='ignore'))
        ])

        # Composición de transformaciones
        preprocessor = ColumnTransformer(
            transformers=[
                ('num', numeric_transformer, numeric_features),
                ('cat', categorical_transformer, categorical_features)
            ],
            remainder='drop'  # Ignorar las columnas que no se transforman
        )
        
        return preprocessor

    # Método para limpiar los datos
    def clean_data(self):
        if self.data is not None:
            self.progress.start()  # Iniciar barra de progreso
            self.impute_missing_values()  # Imputar valores faltantes
            self.progress.stop()  # Detener barra de progreso
            self.label.config(text="Datos limpiados.")
            self.save_button.config(state=tk.NORMAL)  # Habilitar el botón de guardar datos

    # Método para guardar los datos limpiados
    def save_data(self):
        try:
            self.data.to_csv("cleaned_data.csv", index=False)  # Guardar los datos en un archivo CSV
            self.label.config(text="Datos guardados como 'cleaned_data.csv'")
        except Exception as e:
            self.label.config(text=f"Error al guardar el archivo: {str(e)}")

    # Método para imputar valores faltantes en las columnas
    def impute_missing_values(self):
        for column in self.data.columns:
            if self.data[column].isnull().any():
                if self.evaluate_imputation(column) <= 0.1:  # Umbral para MSE aceptable
                    self.impute_column(column)
                else:
                    print(f"Column {column} has high MSE for imputation. Skipping.")

    # Método para imputar una columna específica
    def impute_column(self, column):
        df = self.data.copy()
        train = df[df[column].notnull()]
        test = df[df[column].isnull()]

        if not test.empty:
            X_train = train.drop(columns=[column])
            y_train = train[column]
            X_test = test.drop(columns=[column])

            preprocessor = self.preprocess_data(X_train)
            X_train = preprocessor.fit_transform(X_train)
            X_test = preprocessor.transform(X_test)

            param_grid = {'max_depth': [3, 5, 7, 10], 'min_samples_split': [2, 5, 10]}
            tree = GridSearchCV(DecisionTreeRegressor(), param_grid, cv=3)  # Búsqueda de mejores parámetros con validación cruzada
            tree.fit(X_train, y_train)

            predicted_values = tree.predict(X_test)
            self.data.loc[self.data[column].isnull(), column] = predicted_values

    # Método para evaluar la imputación de una columna
    def evaluate_imputation(self, column):
        df = self.data.copy()
        df_known = df[df[column].notnull()]
        df_unknown = df[df[column].isnull()]

        if not df_unknown.empty:
            X_train = df_known.drop(columns=[column])
            y_train = df_known[column]

            preprocessor = self.preprocess_data(X_train)
            X_train = preprocessor.fit_transform(X_train)

            param_grid = {'max_depth': [3, 5, 7, 10], 'min_samples_split': [2, 5, 10]}
            tree = GridSearchCV(DecisionTreeRegressor(), param_grid, cv=3)  # Búsqueda de mejores parámetros con validación cruzada
            tree.fit(X_train, y_train)

            X_test = X_train
            y_pred = tree.predict(X_test)
            
            mse = mean_squared_error(y_train, y_pred)  # Calcular el error cuadrático medio
            print(f'Mean Squared Error for column {column}: {mse}')
            return mse  # Devolver el valor de MSE

if __name__ == "__main__":
    root = tk.Tk()
    app = DataCleanerApp(root)
    root.mainloop()  # Iniciar el loop de eventos de Tkinter
